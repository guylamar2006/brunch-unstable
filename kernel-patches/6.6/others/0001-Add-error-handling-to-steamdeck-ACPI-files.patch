From a6817ed444e0eeb8acea296deb21d651ebfc248a Mon Sep 17 00:00:00 2001
From: Guy Chronister <guyc.linux.patches@gmail.com>
Date: Sun, 22 Dec 2024 12:04:54 -0600
Subject: [PATCH] Add error handling to steamdeck ACPI files.

---
 drivers/extcon/Kconfig            |   8 ++
 drivers/extcon/Makefile           |   1 +
 drivers/extcon/extcon-steamdeck.c | 122 ++++++++++++++++++++++++++++++
 drivers/hwmon/Kconfig             |  11 +++
 drivers/hwmon/Makefile            |   1 +
 drivers/hwmon/steamdeck-hwmon.c   |  77 +++++++++++++++++++
 drivers/leds/Kconfig              |   7 ++
 drivers/leds/Makefile             |   1 +
 drivers/leds/leds-steamdeck.c     |  76 +++++++++++++++++++
 drivers/mfd/Kconfig               |  11 +++
 drivers/mfd/Makefile              |   2 +
 drivers/mfd/steamdeck.c           |  64 ++++++++++++++++
 12 files changed, 381 insertions(+)
 create mode 100644 drivers/extcon/extcon-steamdeck.c
 create mode 100644 drivers/hwmon/steamdeck-hwmon.c
 create mode 100644 drivers/leds/leds-steamdeck.c
 create mode 100644 drivers/mfd/steamdeck.c

diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index cf472e44c5ff..f90504acd6db 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -192,4 +192,12 @@ config EXTCON_USBC_TUSB320
 	  Say Y here to enable support for USB Type C cable detection extcon
 	  support using a TUSB320.
 
+config EXTCON_STEAMDECK
+	tristate "Steam Deck extcon support"
+	depends on MFD_STEAMDECK
+	help
+	  Say Y here to enable support of USB Type C cable detection extcon
+	  support on Steam Deck devices
+
+
 endif
diff --git a/drivers/extcon/Makefile b/drivers/extcon/Makefile
index 1b390d934ca9..1c7e217f29e4 100644
--- a/drivers/extcon/Makefile
+++ b/drivers/extcon/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_EXTCON_SM5502)	+= extcon-sm5502.o
 obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
 obj-$(CONFIG_EXTCON_USBC_TUSB320) += extcon-usbc-tusb320.o
+obj-$(CONFIG_EXTCON_STEAMDECK)  += extcon-steamdeck.o
diff --git a/drivers/extcon/extcon-steamdeck.c b/drivers/extcon/extcon-steamdeck.c
new file mode 100644
index 000000000000..253ee5dcbda9
--- /dev/null
+++ b/drivers/extcon/extcon-steamdeck.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+static void steamdeck_usb_role_work(struct work_struct *work)
+{
+	struct steamdeck_extcon *sd =
+		container_of(work, struct steamdeck_extcon, role_work.work);
+	unsigned long long pdcs;
+	bool usb_host;
+	int ret;
+
+	if (steamdeck_read_pdcs(sd, &pdcs)) {
+		dev_err(sd->dev, "Failed to read PDCS status\n");
+		return;
+	}
+
+	pdcs &= ACPI_STEAMDECK_PORT_CONNECT | ACPI_STEAMDECK_CUR_DATA_ROLE;
+
+	usb_host = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+		pdcs & ACPI_STEAMDECK_CUR_DATA_ROLE : false;
+
+	dev_dbg(sd->dev, "USB role is %s\n", usb_host ? "host" : "device");
+	ret = extcon_set_state_sync(sd->edev, EXTCON_USB_HOST, usb_host);
+	if (ret)
+		dev_err(sd->dev, "Failed to set extcon state: %d\n", ret);
+}
+
+static void steamdeck_notify(acpi_handle handle, u32 event, void *context)
+{
+	struct device *dev = context;
+	struct steamdeck_extcon *sd = dev_get_drvdata(dev);
+	unsigned long long pdcs;
+	unsigned long delay;
+
+	if (!sd) {
+		pr_err("steamdeck-extcon: Invalid driver data\n");
+		return;
+	}
+
+	switch (event) {
+	case ACPI_STEAMDECK_NOTIFY_STATUS:
+		if (steamdeck_read_pdcs(sd, &pdcs)) {
+			dev_err(dev, "Failed to read PDCS in notify handler\n");
+			return;
+		}
+		delay = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+			STEAMDECK_ROLE_SWITCH_DELAY : 0;
+
+		if (!queue_delayed_work(system_long_wq, &sd->role_work, delay))
+			dev_warn(dev, "Work item already queued\n");
+		break;
+	default:
+		dev_warn(dev, "Unsupported event [0x%x]\n", event);
+	}
+}
+
+static int steamdeck_extcon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct steamdeck_extcon *sd;
+	acpi_status status;
+	int ret;
+
+	if (!dev) {
+		pr_err("steamdeck-extcon: Invalid platform device\n");
+		return -EINVAL;
+	}
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	INIT_DELAYED_WORK(&sd->role_work, steamdeck_usb_role_work);
+	platform_set_drvdata(pdev, sd);
+	sd->adev = ACPI_COMPANION(dev->parent);
+	if (!sd->adev) {
+		dev_err(dev, "No ACPI companion device found\n");
+		return -ENODEV;
+	}
+
+	sd->dev = dev;
+	sd->edev = devm_extcon_dev_allocate(dev, steamdeck_extcon_cable);
+	if (IS_ERR(sd->edev)) {
+		ret = PTR_ERR(sd->edev);
+		dev_err(dev, "Failed to allocate extcon device: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_extcon_dev_register(dev, sd->edev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register extcon device: %d\n", ret);
+		return ret;
+	}
+
+	queue_delayed_work(system_long_wq, &sd->role_work, 0);
+	flush_delayed_work(&sd->role_work);
+
+	status = acpi_install_notify_handler(sd->adev->handle,
+					   ACPI_DEVICE_NOTIFY,
+					   steamdeck_notify,
+					   dev);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to install ACPI notify handler: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_notify_handler, sd);
+	if (ret) {
+		dev_err(dev, "Failed to add removal action: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "Steam Deck extcon driver initialized successfully\n");
+	return 0;
+}
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index ec38c8892158..d945d49201d3 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1941,6 +1941,17 @@ config SENSORS_SCH5636
 	  This driver can also be built as a module. If so, the module
 	  will be called sch5636.
 
+config SENSORS_STEAMDECK
+	tristate "Steam Deck EC sensors"
+	depends on MFD_STEAMDECK
+	help
+	  If you say yes here you get support for the hardware
+	  monitoring features exposed by EC firmware on Steam Deck
+	  devices
+
+	  This driver can also be built as a module. If so, the module
+	  will be called steamdeck-hwmon.
+
 config SENSORS_STTS751
 	tristate "ST Microelectronics STTS751"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 4ac9452b5430..3db944de8465 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -197,6 +197,7 @@ obj-$(CONFIG_SENSORS_SMSC47B397)+= smsc47b397.o
 obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
 obj-$(CONFIG_SENSORS_SPARX5)	+= sparx5-temp.o
+obj-$(CONFIG_SENSORS_STEAMDECK) += steamdeck-hwmon.o
 obj-$(CONFIG_SENSORS_STTS751)	+= stts751.o
 obj-$(CONFIG_SENSORS_SY7636A)	+= sy7636a-hwmon.o
 obj-$(CONFIG_SENSORS_AMC6821)	+= amc6821.o
diff --git a/drivers/hwmon/steamdeck-hwmon.c b/drivers/hwmon/steamdeck-hwmon.c
new file mode 100644
index 000000000000..6e977ca04dab
--- /dev/null
+++ b/drivers/hwmon/steamdeck-hwmon.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+static long
+steamdeck_hwmon_get(struct steamdeck_hwmon *sd, const char *method)
+{
+	unsigned long long val;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(sd->adev->handle, (char *)method, NULL, &val);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&sd->adev->dev, "Failed to evaluate ACPI method %s: %s\n",
+			method, acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return val;
+}
+
+static int steamdeck_hwmon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct steamdeck_hwmon *sd;
+	struct device *hwmon;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	sd->adev = ACPI_COMPANION(dev->parent);
+	if (!sd->adev) {
+		dev_err(dev, "No ACPI companion device found\n");
+		return -ENODEV;
+	}
+
+	hwmon = devm_hwmon_device_register_with_info(dev,
+							 "steamdeck_hwmon",
+							 sd,
+							 &steamdeck_hwmon_chip_info,
+							 steamdeck_hwmon_groups);
+	if (IS_ERR(hwmon)) {
+		dev_err(dev, "Failed to register HWMON device: %ld\n", PTR_ERR(hwmon));
+		return PTR_ERR(hwmon);
+	}
+
+	dev_info(dev, "Steam Deck HWMON driver initialized\n");
+	return 0;
+}
+
+static int
+steamdeck_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+			  u32 attr, int channel, long val)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+	acpi_status status;
+
+	if (type != hwmon_fan ||
+		attr != hwmon_fan_target)
+		return -EOPNOTSUPP;
+
+	val = clamp_val(val, 0, 7300);
+
+	status = acpi_execute_simple_method(sd->adev->handle, "FANS", val);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to execute FANS method: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return 0;
+}
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 3132439f99e0..f378ffb1239b 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -892,6 +892,13 @@ config LEDS_ACER_A500
 	  This option enables support for the Power Button LED of
 	  Acer Iconia Tab A500.
 
+config LEDS_STEAMDECK
+	tristate "LED support for Steam Deck"
+	depends on LEDS_CLASS && MFD_STEAMDECK
+	help
+	  This option enabled support for the status LED (next to the
+	  power button) on Steam Deck
+
 source "drivers/leds/blink/Kconfig"
 
 comment "Flash and Torch LED drivers"
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index d7348e8bc019..411aec617000 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_LEDS_POWERNV)		+= leds-powernv.o
 obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
+obj-$(CONFIG_LEDS_STEAMDECK)		+= leds-steamdeck.o
 obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
 obj-$(CONFIG_LEDS_SYSCON)		+= leds-syscon.o
 obj-$(CONFIG_LEDS_TCA6507)		+= leds-tca6507.o
diff --git a/drivers/leds/leds-steamdeck.c b/drivers/leds/leds-steamdeck.c
new file mode 100644
index 000000000000..f6bbc2a58ec1
--- /dev/null
+++ b/drivers/leds/leds-steamdeck.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+// Add debug messages in led_brightness_multiplier_show
+static ssize_t led_brightness_multiplier_show(struct device *dev,
+						  struct device_attribute *attr,
+						  char *buf)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long long led_brightness_multiplier;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(sd->adev->handle,
+						   "GLDM",
+						   NULL,
+						   &led_brightness_multiplier);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to get LED brightness multiplier: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return sprintf(buf, "%llu", led_brightness_multiplier);
+}
+
+// Add debug messages in led_brightness_multiplier_store
+static ssize_t led_brightness_multiplier_store(struct device *dev,
+						   struct device_attribute *attr,
+						   const char *buf, size_t count)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long value;
+	acpi_status status;
+
+	if (kstrtoul(buf, 10, &value) || value > 100) {
+		dev_err(dev, "Invalid brightness multiplier value: %s\n", buf);
+		return -EINVAL;
+	}
+
+	status = acpi_execute_simple_method(sd->adev->handle, "SLDM", value);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to set LED brightness multiplier: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return count;
+}
+
+// Add debug messages in steamdeck_leds_brightness_set
+static int steamdeck_leds_brightness_set(struct led_classdev *cdev,
+					 enum led_brightness value)
+{
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	acpi_status status;
+
+	status = acpi_execute_simple_method(sd->adev->handle, "CHBV", value);
+	if (ACPI_FAILURE(status)) {
+		dev_err(cdev->dev, "Failed to set LED brightness: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return 0;
+}
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 68d71b4b55bd..55ba0b2bf59b 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -2333,5 +2333,16 @@ config MFD_RSMU_SPI
 	  Additional drivers must be enabled in order to use the functionality
 	  of the device.
 
+config MFD_STEAMDECK
+	tristate "Valve Steam Deck"
+	select MFD_CORE
+	depends on ACPI
+	depends on X86_64 || COMPILE_TEST
+	help
+	  This driver registers various MFD cells that expose aspects
+	  of Steam Deck specific ACPI functionality.
+
+	  Say N here, unless you are running on Steam Deck hardware.
+
 endmenu
 endif
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index db1ba39de3b5..ef33d3267c2f 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -282,3 +282,5 @@ obj-$(CONFIG_MFD_ATC260X_I2C)	+= atc260x-i2c.o
 
 obj-$(CONFIG_MFD_RSMU_I2C)	+= rsmu_i2c.o rsmu_core.o
 obj-$(CONFIG_MFD_RSMU_SPI)	+= rsmu_spi.o rsmu_core.o
+
+obj-$(CONFIG_MFD_STEAMDECK)	+= steamdeck.o
diff --git a/drivers/mfd/steamdeck.c b/drivers/mfd/steamdeck.c
new file mode 100644
index 000000000000..863353d9234d
--- /dev/null
+++ b/drivers/mfd/steamdeck.c
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+static int steamdeck_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	unsigned long long sta;
+	struct steamdeck *sd;
+	acpi_status status;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+	sd->adev = ACPI_COMPANION(dev);
+	if (!sd->adev) {
+		dev_err(dev, "No ACPI companion device found\n");
+		return -ENODEV;
+	}
+	sd->dev = dev;
+	platform_set_drvdata(pdev, sd);
+
+	status = acpi_evaluate_integer(sd->adev->handle, "_STA",
+					   NULL, &sta);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Status check failed (status: 0x%x)\n", status);
+		return -EINVAL;
+	}
+
+	if ((sta & STEAMDECK_STA_OK) != STEAMDECK_STA_OK) {
+		dev_err(dev, "Device is not ready (status: 0x%llx)\n", sta);
+		return -EINVAL;
+	}
+
+	ret = sysfs_create_groups(&dev->kobj, steamdeck_groups);
+	if (ret) {
+		dev_err(dev, "Failed to create sysfs groups (err: %d)\n", ret);
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_sysfs_groups,
+					   sd);
+	if (ret) {
+		dev_err(dev, "Failed to register devres action (err: %d)\n", ret);
+		return ret;
+	}
+
+	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,
+					steamdeck_cells, ARRAY_SIZE(steamdeck_cells),
+					NULL, 0, NULL);
+	if (ret) {
+		dev_err(dev, "Failed to add MFD devices (err: %d)\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "Steam Deck EC MFD core driver initialized successfully\n");
+	return 0;
+}
-- 
2.47.1

